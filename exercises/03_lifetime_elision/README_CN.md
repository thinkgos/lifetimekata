# 为什么大多从未使用过周期标注

在上一章中, 了解了我们为什么需要生命周期. 我们看到编译器无法自动地确定参数或返回值中的引用之间如何关联. 这就是为什么需要我们告诉编译器引用是如何相互关联的.

这么说吧, 你可能在`Rust`中编写过一个需要引用(通常是`&str`类型)的函数, 而且并没有显式地标注生命周期. 为什么在这种情况下你不需要注明生命周期呢? 原因是在`Rust`中存在一些常见的模式, 它们使编译器明确知道使用了哪些生命周期. 让我们来探讨一些常见的模式:

## 例1: 没有返回引用

``` rust
fn add(a: &i32, b: &i32) -> i32 {
    *a + *b
}

# fn main() {
#     assert_eq!(add(&3, &4), 7);
# }
```

这个函数中变量`'a`和`'b`的生命周期不需要有关联. 假设只有一个线程, 并且假设代码是安全的, 在函数执行过程中, 这两个变量所引用的变量不可能在函数内被释放. 在函数执行完毕之后, 它们可以一直存在, 直到自己的生命周期结束.

## 列2: 只有一个输入引用

``` rust
fn identity(a: &i32) -> &i32 {
    a
}

# fn main() {
#     let x = 52;
#     assert_eq!(&x, identity(&x));
# }
```

需要注意的是,通常情况(*附注: 这在静态类型中是可能的, 比如字符串字面量, 不过我们稍后会涵盖这些内容.*),  
如果在函数没有提供给你一个引用, 那么就不可能创建一个引用并将其传出该函数. 这是因为引用必须指向你拥有的内容. 你拥有的任何内容都会在函数结束时被丢弃. 因此, 函数内任何你拥有的内容都不能被引用并传出该函数;  
而如果你被传递了一个引用, 你唯一能够返回一个引用的方式就是传递该引用.  
如果在您的参数中只有一个引用, 那么您返回的唯一引用就是那个引用 -- 因此, 您返回的引用的生命周期与参数相同.

## 怎么做

`Rust`本可以将特殊编码的示例作为异常; 但这样一来, 可能会有许多情况被作为异常, 从而导致混乱的规则. 相反, `Rust` 项目已经确定了一种规则, 编译器将遵循这个规则来尝试和猜测生命周期.

编译器首先将函数签名中的所有引用分为两种类型:`'input'`和`'output'`.
`'Input'`引用是指函数参数(即其参数). `'Output'`引用是指函数的返回类型中的引用.

我们将在本章中学习的两条规则是:

- 每个没有提供输入生命周期的参数都将分配其各自独立的生命周期
- 如果所有输入引用上有且只有一个生命周期, 那么那个生命周期就会被赋予*每个*输出.

让我们看看这些规则如何影响上面的两个例子, 以及上一章的一个例子:

### 例1: 没有输出引用

我们有:

``` rust,ignore
fn add(a: &mut i32, b: &mut i32) -> i32 {
    *a + *b
}
```

有两个输入生命周期, 分别作用在变量`a`和`b`的类型. 每个变量都被分配了自己的生命周期:

``` rust
fn add<'elided1, 'elided2>(a: &'elided1 i32, b: &'elided2 i32) -> i32 {
    *a + *b
}

# fn main() {
#     assert_eq!(add(&3, &4), 7);
# }
```

没有输出生命周期, 所以我们就到这里结束.

这个例子现在是正确的 -- `a` 和 `b` 的两个生命周期可以完全无关;而输出是一个拥有的值, 因此它不依赖于任何生命周期.

### 例2: 只有一个输入引用

我们有:

``` rust
fn identity(a: &i32) -> &i32 {
    a
}

# fn main() {
#     let x = 52;
#     assert_eq!(&x, identity(&x));
# }
```

只有一个输入生命周期(针对类型`a`的):

``` rust
fn identity<'elided1>(a: &'elided1 i32) -> &i32 {
    a
}

# fn main() {
#     let x = 52;
#     assert_eq!(&x, identity(&x));
# }
```

只有一个输出生命周期; 而所有输入生命周期共享相同的生命周期(`'elided1`).
因此, 我们可以分配该生命周期给所有输出:

``` rust
fn identity<'elided1>(a: &'elided1 i32) -> &'elided1 i32 {
    a
}

# fn main() {
#     let x = 52;
#     assert_eq!(&x, identity(&x));
# }
```

现在这已经有意义了: 你能够返回一个`&i32`的唯一可能方式是从一个参数中获得它;而且我们可以看出输入和输出拥有相同的生命周期.

### 例3: 省略限制

让我们再来看一下上一章的这个例子.

``` rust,ignore
fn max_of_refs(a: &i32, b: &i32) -> &i32 {
    if *a > *b {
        a
    } else {
        b
    }
}
```

和示例1一样, 这里有两个输入, 因此我们赋予它们不同的生命周期. :

``` rust,ignore
fn max_of_refs<'elided1, 'elided2>(a: &'elided1 i32, b: &'elided2 i32) -> &i32 {
    if *a > *b {
        a
    } else {
        b
    }
}
```

与示例1不同, 我们需要一个输出生命周期！根据第二条规则, 只有当我们有且仅有一个输入生命周期时, 才可以省略输出生命周期. 因此, `Rust`认为在这里省略生命周期是错误的 -- 用户必须提供更多信息！

## 练习: 应用这些规则

在这个练习中, 有四个函数缺少一些生命周期注解.
你的任务是按照生命周期省略规则, 像编译器一样为这些函数添加生命周期

在未来的`lifetimekata`版本中, 这些将会自动进行检查. 而现在, 在你完成后, 将你的答案与解决方案进行比较.
