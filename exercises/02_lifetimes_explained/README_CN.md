# 生命周期: 悬空引用的解决方案

我们在这里看到, 悬空引用发生的原因是函数丢失有关引用来源的信息.

编译器只有在知道输入和输出的生命周期如何相互作用时, 才能决定函数是否正确.
因此, 我们需要在输入和输出的生命周期相同时告诉编译器.

我们可以做的是告诉计算机: "只要这些输入/输出的生命周期相同,我的函数就适用于任何生命周期".
让我们来看一下这个语法:

```rust
fn some_if_greater<'lifetime1, 'lifetime2>(number: &'lifetime1 i32, greater_than: &'lifetime2 i32) -> Option<&'lifetime1 i32> {
    if number > greater_than {
        Some(number)
    } else {
        None
    }
}
# fn main() {
#     let (n, gt) = (7, 4);
#     let test = some_if_greater(&n, &gt);
# }
```

让我们来看下这个做了什么:

- `fn my_function<'lifetime1, 'lifetime2>(...)`: 我们在这里做的是为程序所需的生命周期选择相应名称.
- `number: &'lifetime1 i32`: 这个是我们告诉编译器, 这个引用必须在一个被称为`'lifetime1`的代码区域内存在.
- `greater_than: &'lifetime2 i32`: 这是我们告诉编译器这个引用必须在一个被称为`'lifetime2`的代码区域中存在.
这意味着 `greater_than` 和 `number` 的生命周期没有任何关联.
- `-> Option<&'lifetime1 i32>`: 这正是生命周期至关重要的地方.
我们所要表达的是, `number` 变量和我们的返回值必须在完全相同的代码区域内有效.

所以, 我们所做的是告诉编译器, 只有在`number`和返回值在相同的代码区域有效时才能调用我们的函数.

## 练习: 标注生命周期

为了进行一些初始练习, 本节的练习是对前两章中的一些示例进行生命周期标注.

你需要:

- 决定需要多少个生命周期参数
- 为每个生命周期参数命名, 在函数名后使用`<`尖括号`>`括起来
- 在每个引用处添加适当的生命周期注解
- 检查代码是否能够编译通过
- 思考每个生命周期可能适用于代码的哪个区域

你会注意到每个函数都有`#[lifetimes_required(!)]`注解.你需要将它保留在那里以完成这个练习.
这会指示编译器在你遗漏了生命周期的情况下抛出错误; 即使编译器并不需要这个生命周期.
